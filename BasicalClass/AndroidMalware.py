from model.android import *
import torch.nn as nn
from BasicalClass.common_function import *
import torch.optim as optim


class Android_Module:
    def __init__(self, device, load_poor = False):
        self.clip = (-0.1, 1.1
                     )
        self.device = device
        self.load_poor = load_poor
        if not load_poor:
            self.model = self.load_model().to(self.device)
        else:
            self.model = self.load_poor_model().to(self.device)
        self.model.eval()
        print('model name is ', self.model.__class__.__name__)

        self.train_batch_size = 64
        self.test_batch_size = 64 if IS_DEBUG else 1000
        self.name = 'AndroidMalware'
        self.train_x, self.train_y = self.load_data(True)
        self.train_pred_pos, self.train_pred_y = \
            common_predict(self.train_x, self.model, self.test_batch_size, self.device)

        self.test_x, self.test_y = self.load_data(False)
        self.test_pred_pos, self.test_pred_y = \
            common_predict(self.test_x, self.model, self.test_batch_size, self.device)

        self.input_shape = (282515)
        self.optimizer = optim.Adam(self.model.parameters(), lr=0.01)
        self.class_num = 2
        self.acc = common_cal_accuracy(self.test_pred_y, self.test_y)
        self.train_acc = common_cal_accuracy(self.train_pred_y, self.train_y)
        self.criterion = nn.CrossEntropyLoss()
        self.eps = 200

        if not os.path.isdir('./' + self.name):
            os.mkdir('./' + self.name)
        print('construct the module', self.name, 'the accuracy is %0.3f, %0.3f' % (self.train_acc, self.acc))
        print('training data number is', len(self.train_x), 'test data number is ', len(self.test_x))

    def load_model(self):
        model = Android_MLP(feature_num= 282515)
        state_dict = torch.load('./model_weight/android/MLP.h5', map_location=self.device)
        model.load_state_dict(state_dict)
        return model.to(self.device)

    def load_poor_model(self):
        model = Android_Poor(feature_num=282515)
        state_dict = torch.load('./model_weight/android/' + model.__class__.__name__ + '.h5', map_location=self.device)
        model.load_state_dict(state_dict)
        return model.to(self.device)

    def load_data(self, is_train=True):
        if is_train:
            x = np.load('data/android_malware/x_train.npy')
            y = np.load('data/android_malware/y_train.npy')
            if IS_DEBUG:
                x, y = x[:100], y[:100]
            return torch.tensor(x, dtype=torch.float), torch.tensor(y, dtype=torch.long).reshape([-1])
        else:
            x = np.load('data/android_malware/x_test.npy')
            y = np.load('data/android_malware/y_test.npy')
            if IS_DEBUG:
                x, y = x[:100], y[:100]
            return torch.tensor(x, dtype=torch.float), torch.tensor(y, dtype=torch.long).reshape([-1])


    def get_hiddenstate(self, dataset):
        data_loader = DataLoader(dataset, batch_size=self.train_batch_size,
            shuffle=False, collate_fn=None,
        )
        data_num = 0
        sub_num = self.model.sub_num
        sub_res_list = [[] for _ in sub_num]
        for i, x in enumerate(data_loader):
            data_num += len(x)
            x = x.to(self.device)
            self.model.to(self.device)
            sub_y = self.model.get_hidden(x)
            for j in range(len(sub_num)):
                sub_res_list[j].append(sub_y[j])
            if IS_DEBUG and i >= DEBUG_NUM:
                break
        sub_res_list = [torch.cat(i, dim = 0) for i in sub_res_list]
        return sub_res_list, sub_num

def main():
    m = Android_Module()
    print()


if __name__ == '__main__':
    main()